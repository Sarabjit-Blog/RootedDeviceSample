package blog.sarabjit.rooteddevicesample;

import android.content.pm.PackageManager;
import android.support.v4.util.ArrayMap;
import android.util.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class RootUtil {

    private static final String[] DANGEROUS_APPS_PACKAGES = {"com.koushikdutta.rommanager",
            "com.koushikdutta.rommanager.license", "com.dimonvideo.luckypatcher",
            "com.chelpus.lackypatch", "com.ramdroid.appquarantine", "com.ramdroid.appquarantinepro",
            "com.android.vending.billing.InAppBillingService.COIN", "com.chelpus.luckypatcher"};
    private static final String[] ROOT_APPS_PACKAGES = {"com.noshufou.android.su",
            "com.joeykrim.rootcheck", "com.noshufou.android.su.elite", "eu.chainfire.supersu",
            "com.koushikdutta.superuser", "com.thirdparty.superuser", "com.yellowes.su",
            "com.topjohnwu.magisk"};
    private static final String[] ROOT_CLOAKING_PACKAGES = {"com.devadvance.rootcloak",
            "com.devadvance.rootcloakplus", "de.robv.android.xposed.installer",
            "com.saurik.substrate", "com.zachspong.temprootremovejb", "com.amphoras.hidemyroot",
            "com.amphoras.hidemyrootadfree", "com.formyhm.hiderootPremium", "com.formyhm.hideroot"};
    private static final String[] SU_PATHS = {"/data/local/", "/data/local/bin/", "/data/local/xbin/",
            "/sbin/", "/su/bin/", "/system/bin/", "/system/bin/.ext/", "/system/bin/failsafe/",
            "/system/sd/xbin/", "/system/usr/we-need-root/", "/system/xbin/", "/cache", "/data", "/dev"};
    private static final String[] PATHS_THAT_SHOULD_NOT_BE_WRITABLE = {"/system", "/system/bin",
            "/system/sbin", "/system/xbin", "/vendor/bin", "/sbin", "/etc"};
    private static final String SU = "su";
    private static final String TAG = "RootUtil";
    private static final String GETPROP = "getprop";
    private static final String MOUNT = "mount";
    private static final String RO_DEBUGGABLE = "ro.debuggable";
    private static final String RO_SECURE = "ro.secure";
    private static final String RW = "rw";
    private static final String WHICH = "which";
    private static final String DELIMETER_A = "\\A";
    private static final String OPEN_BRACKET = "[";
    private static final String CLOSING_BRACKET = "]";
    private static final String TEST_KEYS = "test-keys";
    private static final String MAGISK = "magisk";

    /**
     * @return true, if rooted else false
     */
    public boolean isRooted() {
        boolean isRootManagementApplicationInstalled = detectRootManagementApps();
        boolean isPotentiallyDangerousAppsInstalled = detectPotentiallyDangerousApps();
        boolean isRootCloakingApplicationInstalled = detectRootCloakingApps();
        boolean isSuBinaryFileExists = isSuBinaryFileExists();
        boolean isDangerousPropsExists = checkForDangerousProps();
        boolean isRWPaths = checkForRWPaths();
        boolean isTestKeysAvailable = detectTestKeys();
        boolean isSuCommandExecutes = isSuCommandExecutes();
        boolean isMagiskBinaryFileExists = isMagiskBinaryFileExists();
        boolean isThirdPartyApp = isRootManagementApplicationInstalled || isPotentiallyDangerousAppsInstalled
                || isRootCloakingApplicationInstalled;
        boolean isSuOrDangerousPath = isSuBinaryFileExists || isSuCommandExecutes || isDangerousPropsExists;
        boolean isTestOrMagiskOrRW = isRWPaths || isTestKeysAvailable || isMagiskBinaryFileExists;
        return isThirdPartyApp || isSuOrDangerousPath || isTestOrMagiskOrRW;
    }

    /**
     * test-keys means kernel is signed with custom key generated by a third-party developer.
     *
     * @return true if signed with test-keys
     */
    private boolean detectTestKeys() {
        String buildTags = android.os.Build.TAGS;
        return buildTags != null && buildTags.contains(TEST_KEYS);
    }

    /**
     * check for root apps using PackageManager. @link {PerfConstant.ROOT_APPS_PACKAGES}
     *
     * @return true if one of the rooting app is installed else false
     */
    private boolean detectRootManagementApps() {
        ArrayList<String> packages = new ArrayList<>();
        packages.addAll(Arrays.asList(ROOT_APPS_PACKAGES));
        return isAnyPackageFromListInstalled(packages);
    }

    /**
     * check for the apps which require root, using PackageManager. @link {PerfConstant.ROOT_APPS_PACKAGES}
     *
     * @return true if root requiring app installed else false
     */
    private boolean detectPotentiallyDangerousApps() {
        ArrayList<String> packages = new ArrayList<>();
        packages.addAll(Arrays.asList(DANGEROUS_APPS_PACKAGES));
        return isAnyPackageFromListInstalled(packages);
    }

    /**
     * check for the root cloaking apps using PackageManager. @link {PerfConstant.ROOT_APPS_PACKAGES}
     *
     * @return true if one of the apps it's installed
     */
    private boolean detectRootCloakingApps() {
        ArrayList<String> packages = new ArrayList<>();
        packages.addAll(Arrays.asList(ROOT_CLOAKING_PACKAGES));
        return isAnyPackageFromListInstalled(packages);
    }

    /**
     * check for common locations of SU binary
     *
     * @return true if found su binary else false
     */
    private boolean isSuBinaryFileExists() {
        return checkForBinary(SU);
    }

    /**
     * Check su_Paths @link {PerfConstant.SU_PATHS} for the MAGISK binary
     *
     * @return true if @link {MAGISK} binary found else false
     */
    private boolean isMagiskBinaryFileExists() {
        return checkForBinary(MAGISK);
    }

    /**
     * checks for binary in common su_Paths  @link {PerfConstant.SU_PATHS}
     *
     * @param filename - check for this existence of this file
     * @return true if found else false
     */
    private boolean checkForBinary(String filename) {

        boolean result = false;

        for (String path : SU_PATHS) {
            File f = new File(path, filename);
            boolean fileExists = f.exists();
            if (fileExists) {
                result = true;
            }
        }
        return result;
    }

    /**
     * @return array of getProp splitted using "\\A"
     */
    private String[] propsReader() {
        try {
            InputStream inputstream = Runtime.getRuntime().exec(GETPROP).getInputStream();
            if (inputstream == null) {
                return new String[0];
            }
            String propVal = new Scanner(inputstream).useDelimiter(DELIMETER_A).next();
            return propVal.split("\n");
        } catch (IOException | NoSuchElementException exception) {
            Log.e(TAG, "RootHelper.propsReader : exception -  " + exception);
            return new String[0];
        }
    }

    /**
     * @return array of mount command splitted using "\\A" and "\n"
     */
    private String[] mountReader() {
        try {
            InputStream inputstream = Runtime.getRuntime().exec(MOUNT).getInputStream();
            if (inputstream == null) {
                return new String[0];
            }
            String propVal = new Scanner(inputstream).useDelimiter(DELIMETER_A).next();
            return propVal.split("\n");
        } catch (IOException | NoSuchElementException exception) {
            Log.e(TAG, "RootHelper.mountReader : exception -  " + exception);
            return new String[0];
        }
    }

    /**
     * Check if any package in the list is installed
     *
     * @param packages - list of packages to search for
     * @return true if any of the packages are installed
     */
    private boolean isAnyPackageFromListInstalled(List<String> packages) {
        boolean result = false;

        PackageManager pm = BaseApplication.getInstance().getPackageManager();

        for (String packageName : packages) {
            try {
                pm.getPackageInfo(packageName, 0);
                result = true;
            } catch (PackageManager.NameNotFoundException exception) {
                Log.e(TAG, "RootHelper.isAnyPackageFromListInstalled : exception -  " + exception);
            }
        }
        return result;
    }

    /**
     * check for system's dangerous properties
     *
     * @return - true if dangerous props found else false
     */
    private boolean checkForDangerousProps() {

        final Map<String, String> dangerousProps = new ArrayMap<>();
        dangerousProps.put(RO_DEBUGGABLE, "1");
        dangerousProps.put(RO_SECURE, "0");

        boolean result = false;

        String[] lines = propsReader();

        if (lines.length == 0) {
            return false;
        }

        for (String line : lines) {
            for (Map.Entry<String, String> entry : dangerousProps.entrySet()) {
                result = isDangerousProps(line, entry);
            }
        }
        return result;
    }

    /**
     * @param line  line
     * @param entry map entry set
     * @return rue if dangerous props found else false
     */
    private boolean isDangerousProps(String line, Map.Entry<String, String> entry) {
        if (line.contains(entry.getKey())) {
            StringBuilder badValue = new StringBuilder(entry.getValue());
            badValue.append(OPEN_BRACKET).append(badValue).append(CLOSING_BRACKET);
            if (line.contains(badValue)) {
                return true;
            }
        }
        return false;
    }

    /**
     * In case of root we can change the permission of common system directories, this method checks
     * if any of these paths  @link {PerfConstant.PATHS_THAT_SHOULD_NOT_BE_WRITABLE} are writable.
     *
     * @return true any of the non writable directory is writable, else false
     */
    public boolean checkForRWPaths() {
        boolean result = false;
        String[] lines = mountReader();
        if (lines.length == 0) {
            return false;
        }
        for (String line : lines) {
            String[] args = line.split(" ");
            if (args.length < 4) {
                continue;
            }
            String mountPoint = args[1];
            String mountOptions = args[3];
            for (String pathToCheck : PATHS_THAT_SHOULD_NOT_BE_WRITABLE) {
                result = checkForRWPathsExtended(mountPoint, mountOptions, pathToCheck);
            }
        }
        return result;
    }

    /**
     * checks if directory is writable
     *
     * @param mountPoint   mount point
     * @param mountOptions mount options
     * @param pathToCheck  path to check
     * @return true if directory is writable else false
     */
    private boolean checkForRWPathsExtended(String mountPoint, String mountOptions,
                                            String pathToCheck) {
        if (mountPoint.equalsIgnoreCase(pathToCheck)) {
            for (String option : mountOptions.split(",")) {
                if (option.equalsIgnoreCase(RW)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * check for 'which su' command
     *
     * @return true if 'which su' command executes else false
     */
    private boolean isSuCommandExecutes() {
        Process process = null;
        try {
            process = Runtime.getRuntime().exec(new String[]{WHICH, SU});
            BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()));
            return in.readLine() != null;
        } catch (IOException exception) {
            Log.e(TAG, "RootHelper.isSuCommandExecutes : exception -  " + exception);
        } finally {
            if (process != null) {
                process.destroy();
            }
        }
        return false;
    }
}
